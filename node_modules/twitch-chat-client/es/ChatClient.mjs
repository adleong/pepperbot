import { __assign, __awaiter, __decorate, __extends, __generator, __read } from "tslib";
import deprecate from '@d-fischer/deprecate';
import { Logger, LogLevel } from '@d-fischer/logger';
import { NullRateLimiter, PartitionedTimeBasedRateLimiter, TimeBasedRateLimiter, TimedPassthruRateLimiter } from '@d-fischer/rate-limiter';
import { delay, Enumerable } from '@d-fischer/shared-utils';
import { IrcClient, MessageTypes } from 'ircv3';
import { getTokenInfo, InvalidTokenError, InvalidTokenTypeError } from 'twitch-auth';
import { rtfm } from 'twitch-common';
import { TwitchCommandsCapability } from "./Capabilities/TwitchCommandsCapability/index.mjs";
import { ClearChat } from "./Capabilities/TwitchCommandsCapability/MessageTypes/ClearChat.mjs";
import { HostTarget } from "./Capabilities/TwitchCommandsCapability/MessageTypes/HostTarget.mjs";
import { RoomState } from "./Capabilities/TwitchCommandsCapability/MessageTypes/RoomState.mjs";
import { UserNotice } from "./Capabilities/TwitchCommandsCapability/MessageTypes/UserNotice.mjs";
import { Whisper } from "./Capabilities/TwitchCommandsCapability/MessageTypes/Whisper.mjs";
import { TwitchMembershipCapability } from "./Capabilities/TwitchMembershipCapability.mjs";
import { TwitchTagsCapability } from "./Capabilities/TwitchTagsCapability/index.mjs";
import { ClearMsg } from "./Capabilities/TwitchTagsCapability/MessageTypes/ClearMsg.mjs";
import { extractMessageId } from "./ChatMessageAttributes.mjs";
import { TwitchPrivateMessage } from "./StandardCommands/TwitchPrivateMessage.mjs";
import { toChannelName, toUserName } from "./Toolkit/UserTools.mjs";
var GENERIC_CHANNEL = 'twjs';
/**
 * An interface to Twitch chat.
 *
 * @inheritDoc
 * @hideProtected
 */
var ChatClient = /** @class */ (function (_super) {
    __extends(ChatClient, _super);
    /**
     * Creates a new Twitch chat client.
     *
     * @expandParams
     *
     * @param authProvider The {@AuthProvider} instance to use for authentication.
     * @param options
     */
    function ChatClient(authProvider, options) {
        if (options === void 0) { options = {}; }
        var _a, _b, _c, _d, _e, _f;
        var _this = _super.call(this, {
            connection: {
                hostName: (_a = options.hostName) !== null && _a !== void 0 ? _a : (((_b = options.webSocket) !== null && _b !== void 0 ? _b : true) ? 'irc-ws.chat.twitch.tv' : 'irc.chat.twitch.tv'),
                secure: (_c = options.ssl) !== null && _c !== void 0 ? _c : true
            },
            credentials: {
                nick: ''
            },
            webSocket: (_d = options.webSocket) !== null && _d !== void 0 ? _d : true,
            logger: __assign({ minLevel: options.logLevel }, ((_e = options.logger) !== null && _e !== void 0 ? _e : {})),
            nonConformingCommands: ['004'],
            channels: options.channels
        }) || this;
        _this._authVerified = false;
        _this._needToShowWhisperWarning = false;
        /**
         * Fires when a user is timed out from a channel.
         *
         * @eventListener
         * @param channel The channel the user is timed out from.
         * @param user The timed out user.
         * @param duration The duration of the timeout, in seconds.
         */
        _this.onTimeout = _this.registerEvent();
        /**
         * Fires when a user is permanently banned from a channel.
         *
         * @eventListener
         * @param channel The channel the user is banned from.
         * @param user The banned user.
         */
        _this.onBan = _this.registerEvent();
        /**
         * Fires when a user upgrades their bits badge in a channel.
         *
         * @eventListener
         * @param channel The channel where the bits badge was upgraded.
         * @param user The user that has upgraded their bits badge.
         * @param ritualInfo Additional information about the upgrade.
         * @param msg The full message object containing all message and user information.
         */
        _this.onBitsBadgeUpgrade = _this.registerEvent();
        /**
         * Fires when the chat of a channel is cleared.
         *
         * @eventListener
         * @param channel The channel whose chat is cleared.
         */
        _this.onChatClear = _this.registerEvent();
        /**
         * Fires when emote-only mode is toggled in a channel.
         *
         * @eventListener
         * @param channel The channel where emote-only mode is being toggled.
         * @param enabled Whether emote-only mode is being enabled. If false, it's being disabled.
         */
        _this.onEmoteOnly = _this.registerEvent();
        /**
         * Fires when followers-only mode is toggled in a channel.
         *
         * @eventListener
         * @param channel The channel where followers-only mode is being toggled.
         * @param enabled Whether followers-only mode is being enabled. If false, it's being disabled.
         * @param delay The time (in minutes) a user needs to follow the channel to be able to talk. Only available when `enabled === true`.
         */
        _this.onFollowersOnly = _this.registerEvent();
        /**
         * Fires when a channel hosts another channel.
         *
         * @eventListener
         * @param channel The hosting channel.
         * @param target The channel that is being hosted.
         * @param viewers The number of viewers in the hosting channel.
         *
         * If you're not logged in as the owner of the channel, this is undefined.
         */
        _this.onHost = _this.registerEvent();
        /**
         * Fires when a channel you're logged in as its owner is being hosted by another channel.
         *
         * @eventListener
         * @param channel The channel that is being hosted.
         * @param byChannel The hosting channel.
         * @param auto Whether the host was triggered automatically (by Twitch's auto-host functionality).
         * @param viewers The number of viewers in the hosting channel.
         */
        _this.onHosted = _this.registerEvent();
        /**
         * Fires when Twitch tells you the number of hosts you have remaining in the next half hour for the channel
         * for which you're logged in as owner after hosting a channel.
         *
         * @eventListener
         * @param channel The hosting channel.
         * @param numberOfHosts The number of hosts remaining in the next half hour.
         */
        _this.onHostsRemaining = _this.registerEvent();
        /**
         * Fires when a user joins a channel.
         *
         * The join/part events are cached by the Twitch chat server and will be batched and sent every 30-60 seconds.
         *
         * Please note that unless you enabled the `requestMembershipEvents` option, this will only react to your own joins.
         *
         * @eventListener
         * @param channel The channel that is being joined.
         * @param user The user that joined.
         */
        _this.onJoin = _this.registerEvent();
        /**
         * Fires when a user leaves ("parts") a channel.
         *
         * The join/part events are cached by the Twitch chat server and will be batched and sent every 30-60 seconds.
         *
         * Please note that unless you enabled the `requestMembershipEvents` option, this will only react to your own parts.
         *
         * @eventListener
         * @param channel The channel that is being left.
         * @param user The user that left.
         */
        _this.onPart = _this.registerEvent();
        /**
         * Fires when a single message is removed from a channel.
         *
         * @eventListener
         * @param channel The channel where the message was removed.
         * @param messageId The ID of the message that was removed.
         * @param msg The full message object containing all message and user information.
         *
         * This is *not* the message that was removed. The text of the message is available using `msg.params.message` though.
         */
        _this.onMessageRemove = _this.registerEvent();
        /**
         * Fires when R9K mode is toggled in a channel.
         *
         * @eventListener
         * @param channel The channel where R9K mode is being toggled.
         * @param enabled Whether R9K mode is being enabled. If false, it's being disabled.
         */
        _this.onR9k = _this.registerEvent();
        /**
         * Fires when host mode is disabled in a channel.
         *
         * @eventListener
         * @param channel The channel where host mode is being disabled.
         */
        _this.onUnhost = _this.registerEvent();
        /**
         * Fires when a user raids a channel.
         *
         * @eventListener
         * @param channel The channel that was raided.
         * @param user The user that has raided the channel.
         * @param raidInfo Additional information about the raid.
         * @param msg The full message object containing all message and user information.
         */
        _this.onRaid = _this.registerEvent();
        /**
         * Fires when a user cancels a raid.
         *
         * @eventListener
         * @param channel The channel where the raid was cancelled.
         * @param msg The full message object containing all message and user information.
         */
        _this.onRaidCancel = _this.registerEvent();
        /**
         * Fires when a user performs a "ritual" in a channel.
         *
         * @eventListener
         * @param channel The channel where the ritual was performed.
         * @param user The user that has performed the ritual.
         * @param ritualInfo Additional information about the ritual.
         * @param msg The full message object containing all message and user information.
         */
        _this.onRitual = _this.registerEvent();
        /**
         * Fires when slow mode is toggled in a channel.
         *
         * @eventListener
         * @param channel The channel where slow mode is being toggled.
         * @param enabled Whether slow mode is being enabled. If false, it's being disabled.
         * @param delay The time (in seconds) a user has to wait between sending messages. Only set when enabling slow mode.
         */
        _this.onSlow = _this.registerEvent();
        /**
         * Fires when sub only mode is toggled in a channel.
         *
         * @eventListener
         * @param channel The channel where sub only mode is being toggled.
         * @param enabled Whether sub only mode is being enabled. If false, it's being disabled.
         */
        _this.onSubsOnly = _this.registerEvent();
        /**
         * Fires when a user subscribes to a channel.
         *
         * @eventListener
         * @param channel The channel that was subscribed to.
         * @param user The subscribing user.
         * @param subInfo Additional information about the subscription.
         * @param msg The full message object containing all message and user information.
         */
        _this.onSub = _this.registerEvent();
        /**
         * Fires when a user resubscribes to a channel.
         *
         * @eventListener
         * @param channel The channel that was resubscribed to.
         * @param user The resubscribing user.
         * @param subInfo Additional information about the resubscription.
         * @param msg The full message object containing all message and user information.
         */
        _this.onResub = _this.registerEvent();
        /**
         * Fires when a user gifts a subscription to a channel to another user.
         *
         * Community subs also fire multiple `onSubGift` events.
         * To prevent alert spam, check [Sub gift spam](/twitch-chat-client/docs/examples/sub-gift-spam).
         *
         * @eventListener
         * @param channel The channel that was subscribed to.
         * @param user The user that the subscription was gifted to. The gifting user is defined in `subInfo.gifter`.
         * @param subInfo Additional information about the subscription.
         * @param msg The full message object containing all message and user information.
         */
        _this.onSubGift = _this.registerEvent();
        /**
         * Fires when a user gifts random subscriptions to the community of a channel.
         *
         * Community subs also fire multiple `onSubGift` events.
         * To prevent alert spam, check [Sub gift spam](/twitch-chat-client/docs/examples/sub-gift-spam).
         *
         * @eventListener
         * @param channel The channel that was subscribed to.
         * @param user The gifting user.
         * @param subInfo Additional information about the community subscription.
         * @param msg The full message object containing all message and user information.
         */
        _this.onCommunitySub = _this.registerEvent();
        /**
         * Fires when a user extends their subscription using a Sub Token.
         *
         * @eventListener
         * @param channel The channel where the subscription was extended.
         * @param user The user that extended their subscription.
         * @param subInfo Additional information about the subscription extension.
         * @param msg The full message object containing all message and user information.
         */
        _this.onSubExtend = _this.registerEvent();
        /**
         * Fires when a user gifts rewards during a special event.
         *
         * @eventListener
         * @param channel The channel where the rewards were gifted.
         * @param user The user that gifted the rewards.
         * @param rewardGiftInfo Additional information about the reward gift.
         * @param msg The full message object containing all message and user information.
         */
        _this.onRewardGift = _this.registerEvent();
        /**
         * Fires when a user upgrades their Prime subscription to a paid subscription in a channel.
         *
         * @eventListener
         * @param channel The channel where the subscription was upgraded.
         * @param user The user that upgraded their subscription.
         * @param subInfo Additional information about the subscription upgrade.
         * @param msg The full message object containing all message and user information.
         */
        _this.onPrimePaidUpgrade = _this.registerEvent();
        /**
         * Fires when a user upgrades their gift subscription to a paid subscription in a channel.
         *
         * @eventListener
         * @param channel The channel where the subscription was upgraded.
         * @param user The user that upgraded their subscription.
         * @param subInfo Additional information about the subscription upgrade.
         * @param msg The full message object containing all message and user information.
         */
        _this.onGiftPaidUpgrade = _this.registerEvent();
        /**
         * Fires when a user gifts a Twitch Prime benefit to the channel.
         *
         * @eventListener
         * @param channel The channel where the benefit was gifted.
         * @param user The user that received the gift.
         *
         * **WARNING:** This is a *display name* and thus will not work as an identifier for the API (login) in some cases.
         * @param subInfo Additional information about the gift.
         * @param msg The full message object containing all message and user information.
         */
        _this.onPrimeCommunityGift = _this.registerEvent();
        /**
         * Fires when a user pays forward a subscription that was gifted to them to a specific user.
         *
         * @eventListener
         * @param channel The channel where the gift was forwarded.
         * @param user The user that forwarded the gift.
         * @param forwardInfo Additional information about the gift.
         * @param msg The full message object containing all message and user information.
         */
        _this.onStandardPayForward = _this.registerEvent();
        /**
         * Fires when a user pays forward a subscription that was gifted to them to the community.
         *
         * @eventListener
         * @param channel The channel where the gift was forwarded.
         * @param user The user that forwarded the gift.
         * @param forwardInfo Additional information about the gift.
         * @param msg The full message object containing all message and user information.
         */
        _this.onCommunityPayForward = _this.registerEvent();
        /**
         * Fires when receiving a whisper from another user.
         *
         * @eventListener
         * @param user The user that sent the whisper.
         * @param message The message text.
         * @param msg The full message object containing all message and user information.
         */
        _this.onWhisper = _this.registerEvent();
        /**
         * Fires when you tried to execute a command you don't have sufficient permission for.
         *
         * @eventListener
         * @param channel The channel that a command without sufficient permissions was executed on.
         * @param message The message text.
         */
        _this.onNoPermission = _this.registerEvent();
        /**
         * Fires when a message you tried to send gets rejected by the ratelimiter.
         *
         * @eventListener
         * @param channel The channel that was attempted to send to.
         * @param message The message text.
         */
        _this.onMessageRatelimit = _this.registerEvent();
        /**
         * Fires when authentication fails.
         *
         * @eventListener
         * @param channel The channel that a command without sufficient permissions was executed on.
         * @param message The message text.
         */
        _this.onAuthenticationFailure = _this.registerEvent();
        /**
         * Fires when sending a message fails.
         *
         * @eventListener
         * @param channel The channel that rejected the message.
         * @param reason The reason for the failure, e.g. you're banned (msg_banned)
         */
        _this.onMessageFailed = _this.registerEvent();
        /**
         * Fires when a user sends a message to a channel.
         *
         * @eventListener
         * @param channel The channel the message was sent to.
         * @param user The user that send the message.
         * @param message The message text.
         * @param msg The full message object containing all message and user information.
         */
        _this.onMessage = _this.registerEvent();
        // internal events to resolve promises and stuff
        _this._onBanResult = _this.registerInternalEvent();
        _this._onTimeoutResult = _this.registerInternalEvent();
        _this._onUnbanResult = _this.registerInternalEvent();
        _this._onColorResult = _this.registerInternalEvent();
        _this._onCommercialResult = _this.registerInternalEvent();
        _this._onDeleteMessageResult = _this.registerInternalEvent();
        _this._onEmoteOnlyResult = _this.registerInternalEvent();
        _this._onEmoteOnlyOffResult = _this.registerInternalEvent();
        _this._onFollowersOnlyResult = _this.registerInternalEvent();
        _this._onFollowersOnlyOffResult = _this.registerInternalEvent();
        _this._onHostResult = _this.registerInternalEvent();
        _this._onUnhostResult = _this.registerInternalEvent();
        _this._onModResult = _this.registerInternalEvent();
        _this._onUnmodResult = _this.registerInternalEvent();
        _this._onModsResult = _this.registerInternalEvent();
        _this._onJoinResult = _this.registerInternalEvent();
        _this._onR9kResult = _this.registerInternalEvent();
        _this._onR9kOffResult = _this.registerInternalEvent();
        _this._onSlowResult = _this.registerInternalEvent();
        _this._onSlowOffResult = _this.registerInternalEvent();
        _this._onSubsOnlyResult = _this.registerInternalEvent();
        _this._onSubsOnlyOffResult = _this.registerInternalEvent();
        _this._onVipResult = _this.registerInternalEvent();
        _this._onUnvipResult = _this.registerInternalEvent();
        _this._onVipsResult = _this.registerInternalEvent();
        if ((authProvider === null || authProvider === void 0 ? void 0 : authProvider.tokenType) === 'app') {
            throw new InvalidTokenTypeError('You can not connect to chat using an AuthProvider that supplies app access tokens.\n' +
                'To get an anonymous, read-only connection, please use `ChatClient.anonymous()`.\n' +
                'To get a read-write connection, please provide an auth provider that provides user access tokens, for example `RefreshableAuthProvider`.');
        }
        _this._chatLogger = new Logger(__assign({ name: 'twitch-chat', emoji: true, minLevel: options.logLevel }, ((_f = options.logger) !== null && _f !== void 0 ? _f : {})));
        _this._authProvider = authProvider;
        _this._useLegacyScopes = !!options.legacyScopes;
        _this._readOnly = !!options.readOnly;
        var executeChatMessageRequest = function (_a) {
            var type = _a.type, message = _a.message, channel = _a.channel, tags = _a.tags;
            return __awaiter(_this, void 0, void 0, function () {
                return __generator(this, function (_b) {
                    if (type === 'say') {
                        _super.prototype.say.call(this, channel, message, tags);
                    }
                    else {
                        _super.prototype.action.call(this, channel, message);
                    }
                    return [2 /*return*/];
                });
            });
        };
        var executeJoinRequest = function (channel) { return __awaiter(_this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                return [2 /*return*/, new Promise(function (resolve, reject) {
                        // eslint-disable-next-line @typescript-eslint/init-declarations
                        var timer;
                        var e = _this._onJoinResult(function (chan, state, error) {
                            if (chan === channel) {
                                clearTimeout(timer);
                                if (error) {
                                    reject(error);
                                }
                                else {
                                    resolve();
                                }
                                _this.removeListener(e);
                            }
                        });
                        timer = setTimeout(function () {
                            _this.removeListener(e);
                            reject(new Error("Did not receive a reply to join " + channel + " in time; assuming that the join failed"));
                        }, 10000);
                        _super.prototype.join.call(_this, channel);
                    })];
            });
        }); };
        var executeWhisperRequest = function (_a) {
            var target = _a.target, message = _a.message;
            return __awaiter(_this, void 0, void 0, function () { return __generator(this, function (_b) {
                return [2 /*return*/, this._doWhisper(target, message)];
            }); });
        };
        if (options.botLevel) {
            if (options.isAlwaysMod) {
                _this._messageRateLimiter = new TimeBasedRateLimiter({
                    bucketSize: options.botLevel === 'verified' ? 7500 : 100,
                    timeFrame: 32000,
                    doRequest: executeChatMessageRequest
                });
            }
            else {
                var bucketSize = 20;
                if (options.botLevel === 'verified') {
                    bucketSize = 7500;
                }
                else if (options.botLevel === 'known') {
                    bucketSize = 50;
                }
                _this._messageRateLimiter = new TimedPassthruRateLimiter(new PartitionedTimeBasedRateLimiter({
                    bucketSize: 1,
                    timeFrame: 1200,
                    logger: { minLevel: LogLevel.ERROR },
                    doRequest: executeChatMessageRequest,
                    getPartitionKey: function (_a) {
                        var channel = _a.channel;
                        return channel;
                    }
                }), { bucketSize: bucketSize, timeFrame: 32000 });
            }
            _this._joinRateLimiter = new TimeBasedRateLimiter({
                bucketSize: options.botLevel === 'verified' ? 2000 : 20,
                timeFrame: 11000,
                doRequest: executeJoinRequest
            });
            var whisperLimitPerSecond = 3;
            var whisperLimitPerMinute = 100;
            if (options.botLevel === 'verified') {
                whisperLimitPerSecond = 20;
                whisperLimitPerMinute = 1200;
            }
            else if (options.botLevel === 'known') {
                whisperLimitPerSecond = 10;
                whisperLimitPerMinute = 200;
            }
            _this._whisperRateLimiter = new TimedPassthruRateLimiter(new TimeBasedRateLimiter({
                bucketSize: whisperLimitPerSecond,
                timeFrame: 1200,
                logger: { minLevel: LogLevel.ERROR },
                doRequest: executeWhisperRequest
            }), { bucketSize: whisperLimitPerMinute, timeFrame: 64000 });
        }
        else {
            _this._needToShowWhisperWarning = true;
            _this._messageRateLimiter = new NullRateLimiter(executeChatMessageRequest);
            _this._joinRateLimiter = new NullRateLimiter(executeJoinRequest);
            _this._whisperRateLimiter = new NullRateLimiter(executeWhisperRequest);
        }
        _this.addCapability(TwitchTagsCapability);
        _this.addCapability(TwitchCommandsCapability);
        if (options.requestMembershipEvents) {
            _this.addCapability(TwitchMembershipCapability);
        }
        _this.addInternalListener(_this.onRegister, function () {
            _this._authVerified = true;
            _this._authFailureMessage = undefined;
        });
        _this.addInternalListener(_this.onPrivmsg, function (channel, user, message, msg) {
            if (user === 'jtv') {
                // 1 = who hosted
                // 2 = auto-host or not
                // 3 = how many viewers (not always present)
                var match = ChatClient_1.HOST_MESSAGE_REGEX.exec(message);
                if (match) {
                    _this.emit(_this.onHosted, channel, match[1], Boolean(match[2]), match[3] ? Number(match[3]) : undefined);
                }
            }
            else {
                _this.emit(_this.onMessage, channel, user, message, msg);
            }
        });
        _this.onTypedMessage(ClearChat, function (_a) {
            var _b = _a.params, channel = _b.channel, user = _b.user, tags = _a.tags;
            if (user) {
                var duration = tags.get('ban-duration');
                if (duration === undefined) {
                    // ban
                    _this.emit(_this.onBan, channel, user);
                }
                else {
                    // timeout
                    _this.emit(_this.onTimeout, channel, user, Number(duration));
                    _this.emit(_this._onTimeoutResult, channel, user, Number(duration));
                }
            }
            else {
                // full chat clear
                _this.emit(_this.onChatClear, channel);
            }
        });
        _this.onTypedMessage(ClearMsg, function (msg) {
            var channel = msg.params.channel, targetMessageId = msg.targetMessageId;
            _this.emit(_this.onMessageRemove, channel, targetMessageId, msg);
        });
        _this.onTypedMessage(HostTarget, function (_a) {
            var _b = _a.params, channel = _b.channel, targetAndViewers = _b.targetAndViewers;
            var _c = __read(targetAndViewers.split(' '), 2), target = _c[0], viewers = _c[1];
            if (target === '-') {
                // unhost
                _this.emit(_this.onUnhost, channel);
            }
            else {
                var numViewers = Number(viewers);
                _this.emit(_this.onHost, channel, target, isNaN(numViewers) ? undefined : numViewers);
            }
        });
        _this.onTypedMessage(MessageTypes.Commands.ChannelJoin, function (_a) {
            var prefix = _a.prefix, channel = _a.params.channel;
            _this.emit(_this.onJoin, channel, prefix.nick);
        });
        _this.onTypedMessage(MessageTypes.Commands.ChannelPart, function (_a) {
            var prefix = _a.prefix, channel = _a.params.channel;
            _this.emit(_this.onPart, channel, prefix.nick);
        });
        _this.onTypedMessage(RoomState, function (_a) {
            var channel = _a.params.channel, tags = _a.tags;
            var isInitial = false;
            if (tags.has('subs-only') && tags.has('slow')) {
                // this is the full state - so we just successfully joined
                _this.emit(_this._onJoinResult, channel, tags);
                isInitial = true;
            }
            if (tags.has('slow')) {
                var slowDelay = Number(tags.get('slow'));
                if (slowDelay) {
                    _this.emit(_this._onSlowResult, channel, slowDelay);
                    if (!isInitial) {
                        _this.emit(_this.onSlow, channel, true, slowDelay);
                    }
                }
                else {
                    _this.emit(_this._onSlowOffResult, channel);
                    if (!isInitial) {
                        _this.emit(_this.onSlow, channel, false);
                    }
                }
            }
            if (tags.has('followers-only')) {
                var followDelay = Number(tags.get('followers-only'));
                if (followDelay === -1) {
                    _this.emit(_this._onFollowersOnlyOffResult, channel);
                    if (!isInitial) {
                        _this.emit(_this.onFollowersOnly, channel, false);
                    }
                }
                else {
                    _this.emit(_this._onFollowersOnlyResult, channel, followDelay);
                    if (!isInitial) {
                        _this.emit(_this.onFollowersOnly, channel, true, followDelay);
                    }
                }
            }
        });
        _this.onTypedMessage(UserNotice, function (userNotice) {
            var _a = userNotice.params, channel = _a.channel, message = _a.message, tags = userNotice.tags;
            var messageType = tags.get('msg-id');
            switch (messageType) {
                case 'sub':
                case 'resub': {
                    var event = messageType === 'sub' ? _this.onSub : _this.onResub;
                    var plan = tags.get('msg-param-sub-plan');
                    var streakMonths = tags.get('msg-param-streak-months');
                    var subInfo = {
                        userId: tags.get('user-id'),
                        displayName: tags.get('display-name'),
                        plan: plan,
                        planName: tags.get('msg-param-sub-plan-name'),
                        isPrime: plan === 'Prime',
                        months: Number(tags.get('msg-param-cumulative-months')),
                        streak: streakMonths ? Number(streakMonths) : undefined,
                        message: message
                    };
                    _this.emit(event, channel, tags.get('login'), subInfo, userNotice);
                    break;
                }
                case 'subgift':
                case 'anonsubgift': {
                    var plan = tags.get('msg-param-sub-plan');
                    var gifter = tags.get('login');
                    var isAnon = messageType === 'anonsubgift' || gifter === 'ananonymousgifter';
                    var subInfo = {
                        userId: tags.get('msg-param-recipient-id'),
                        displayName: tags.get('msg-param-recipient-display-name'),
                        gifter: isAnon ? undefined : gifter,
                        gifterUserId: isAnon ? undefined : tags.get('user-id'),
                        gifterDisplayName: isAnon ? undefined : tags.get('display-name'),
                        gifterGiftCount: isAnon ? undefined : Number(tags.get('msg-param-sender-count')),
                        giftDuration: Number(tags.get('msg-param-gift-months')),
                        plan: plan,
                        planName: tags.get('msg-param-sub-plan-name'),
                        isPrime: plan === 'Prime',
                        months: Number(tags.get('msg-param-months'))
                    };
                    _this.emit(_this.onSubGift, channel, tags.get('msg-param-recipient-user-name'), subInfo, userNotice);
                    break;
                }
                case 'anonsubmysterygift':
                case 'submysterygift': {
                    var gifter = tags.get('login');
                    var isAnon = messageType === 'anonsubmysterygift' || gifter === 'ananonymousgifter';
                    var communitySubInfo = {
                        gifter: isAnon ? undefined : gifter,
                        gifterUserId: isAnon ? undefined : tags.get('user-id'),
                        gifterDisplayName: isAnon ? undefined : tags.get('display-name'),
                        gifterGiftCount: isAnon ? undefined : Number(tags.get('msg-param-sender-count')),
                        count: Number(tags.get('msg-param-mass-gift-count')),
                        plan: tags.get('msg-param-sub-plan')
                    };
                    _this.emit(_this.onCommunitySub, channel, tags.get('login'), communitySubInfo, userNotice);
                    break;
                }
                case 'primepaidupgrade': {
                    var upgradeInfo = {
                        userId: tags.get('user-id'),
                        displayName: tags.get('display-name'),
                        plan: tags.get('msg-param-sub-plan')
                    };
                    _this.emit(_this.onPrimePaidUpgrade, channel, tags.get('login'), upgradeInfo, userNotice);
                    break;
                }
                case 'giftpaidupgrade': {
                    var upgradeInfo = {
                        userId: tags.get('user-id'),
                        displayName: tags.get('display-name'),
                        plan: tags.get('msg-param-sub-plan'),
                        gifter: tags.get('msg-param-sender-login'),
                        gifterDisplayName: tags.get('msg-param-sender-name')
                    };
                    _this.emit(_this.onGiftPaidUpgrade, channel, tags.get('login'), upgradeInfo, userNotice);
                    break;
                }
                case 'standardpayforward': {
                    var wasAnon = tags.get('msg-param-prior-gifter-anonymous') === 'true';
                    var forwardInfo = {
                        userId: tags.get('user-id'),
                        displayName: tags.get('display-name'),
                        originalGifterUserId: wasAnon ? undefined : tags.get('msg-param-prior-gifter-id'),
                        originalGifterDisplayName: wasAnon
                            ? undefined
                            : tags.get('msg-param-prior-gifter-display-name'),
                        recipientUserId: tags.get('msg-param-recipient-id'),
                        recipientDisplayName: tags.get('msg-param-recipient-display-name')
                    };
                    _this.emit(_this.onStandardPayForward, channel, tags.get('login'), forwardInfo, userNotice);
                    break;
                }
                case 'communitypayforward': {
                    var wasAnon = tags.get('msg-param-prior-gifter-anonymous') === 'true';
                    var forwardInfo = {
                        userId: tags.get('user-id'),
                        displayName: tags.get('display-name'),
                        originalGifterUserId: wasAnon ? undefined : tags.get('msg-param-prior-gifter-id'),
                        originalGifterDisplayName: wasAnon
                            ? undefined
                            : tags.get('msg-param-prior-gifter-display-name')
                    };
                    _this.emit(_this.onCommunityPayForward, channel, tags.get('login'), forwardInfo, userNotice);
                    break;
                }
                case 'primecommunitygiftreceived': {
                    var giftInfo = {
                        name: tags.get('msg-param-gift-name'),
                        gifter: tags.get('login'),
                        gifterDisplayName: tags.get('display-name')
                    };
                    _this.emit(_this.onPrimeCommunityGift, channel, tags.get('msg-param-recipient'), giftInfo, userNotice);
                    break;
                }
                case 'raid': {
                    var raidInfo = {
                        displayName: tags.get('msg-param-displayName'),
                        viewerCount: Number(tags.get('msg-param-viewerCount'))
                    };
                    _this.emit(_this.onRaid, channel, tags.get('login'), raidInfo, userNotice);
                    break;
                }
                case 'unraid': {
                    _this.emit(_this.onRaidCancel, channel, userNotice);
                    break;
                }
                case 'ritual': {
                    var ritualInfo = {
                        ritualName: tags.get('msg-param-ritual-name'),
                        message: message
                    };
                    _this.emit(_this.onRitual, channel, tags.get('login'), ritualInfo, userNotice);
                    break;
                }
                case 'bitsbadgetier': {
                    var badgeUpgradeInfo = {
                        displayName: tags.get('display-name'),
                        threshold: Number(tags.get('msg-param-threshold'))
                    };
                    _this.emit(_this.onBitsBadgeUpgrade, channel, tags.get('login'), badgeUpgradeInfo, userNotice);
                    break;
                }
                case 'extendsub': {
                    var extendInfo = {
                        userId: tags.get('user-id'),
                        displayName: tags.get('display-name'),
                        plan: tags.get('msg-param-sub-plan'),
                        months: Number(tags.get('msg-param-cumulative-months')),
                        endMonth: Number(tags.get('msg-param-sub-benefit-end-month'))
                    };
                    _this.emit(_this.onSubExtend, channel, tags.get('login'), extendInfo, userNotice);
                    break;
                }
                case 'rewardgift': {
                    var rewardGiftInfo = {
                        domain: tags.get('msg-param-domain'),
                        gifterId: tags.get('user-id'),
                        gifterDisplayName: tags.get('display-name'),
                        count: Number(tags.get('msg-param-selected-count')),
                        gifterGiftCount: Number(tags.get('msg-param-total-reward-count')),
                        triggerType: tags.get('msg-param-trigger-type')
                    };
                    _this.emit(_this.onRewardGift, channel, tags.get('login'), rewardGiftInfo, userNotice);
                    break;
                }
                default: {
                    _this._chatLogger.warn("Unrecognized usernotice ID: " + messageType);
                }
            }
        });
        _this.onTypedMessage(Whisper, function (whisper) {
            _this.emit(_this.onWhisper, whisper.prefix.nick, whisper.params.message, whisper);
        });
        _this.onTypedMessage(MessageTypes.Commands.Notice, function (_a) {
            var _b = _a.params, channel = _b.target, message = _b.message, tags = _a.tags;
            return __awaiter(_this, void 0, void 0, function () {
                var messageType, _c, match, user, match, match, user, match, user, match, user, remainingHostsFromChar, remainingHosts, match, user, match, match, user, match, _d, modList, mods, match, match, match, user, match, match, user, match, _e, vipList, vips, secs;
                return __generator(this, function (_f) {
                    switch (_f.label) {
                        case 0:
                            messageType = tags.get('msg-id');
                            _c = messageType;
                            switch (_c) {
                                case 'already_banned': return [3 /*break*/, 1];
                                case 'bad_ban_self': return [3 /*break*/, 2];
                                case 'bad_ban_broadcaster': return [3 /*break*/, 3];
                                case 'bad_ban_admin': return [3 /*break*/, 4];
                                case 'bad_ban_global_mod': return [3 /*break*/, 4];
                                case 'bad_ban_staff': return [3 /*break*/, 4];
                                case 'ban_success': return [3 /*break*/, 5];
                                case 'bad_unban_no_ban': return [3 /*break*/, 6];
                                case 'unban_success': return [3 /*break*/, 7];
                                case 'turbo_only_color': return [3 /*break*/, 8];
                                case 'color_changed': return [3 /*break*/, 9];
                                case 'bad_commercial_error': return [3 /*break*/, 10];
                                case 'commercial_success': return [3 /*break*/, 11];
                                case 'bad_delete_message_error': return [3 /*break*/, 12];
                                case 'bad_delete_message_broadcaster': return [3 /*break*/, 12];
                                case 'bad_delete_message_mod': return [3 /*break*/, 12];
                                case 'delete_message_success': return [3 /*break*/, 13];
                                case 'already_emote_only_on': return [3 /*break*/, 14];
                                case 'emote_only_on': return [3 /*break*/, 15];
                                case 'already_emote_only_off': return [3 /*break*/, 16];
                                case 'emote_only_off': return [3 /*break*/, 17];
                                case 'bad_host_hosting': return [3 /*break*/, 18];
                                case 'bad_host_rate_exceeded': return [3 /*break*/, 18];
                                case 'bad_host_error': return [3 /*break*/, 18];
                                case 'hosts_remaining': return [3 /*break*/, 19];
                                case 'not_hosting': return [3 /*break*/, 20];
                                case 'msg_channel_suspended': return [3 /*break*/, 21];
                                case 'bad_mod_banned': return [3 /*break*/, 22];
                                case 'bad_mod_mod': return [3 /*break*/, 22];
                                case 'mod_success': return [3 /*break*/, 23];
                                case 'bad_unmod_mod': return [3 /*break*/, 24];
                                case 'unmod_success': return [3 /*break*/, 25];
                                case 'no_mods': return [3 /*break*/, 26];
                                case 'room_mods': return [3 /*break*/, 27];
                                case 'already_r9k_on': return [3 /*break*/, 28];
                                case 'r9k_on': return [3 /*break*/, 29];
                                case 'already_r9k_off': return [3 /*break*/, 30];
                                case 'r9k_off': return [3 /*break*/, 31];
                                case 'already_subs_on': return [3 /*break*/, 32];
                                case 'subs_on': return [3 /*break*/, 33];
                                case 'already_subs_off': return [3 /*break*/, 34];
                                case 'subs_off': return [3 /*break*/, 35];
                                case 'bad_timeout_self': return [3 /*break*/, 36];
                                case 'bad_timeout_broadcaster': return [3 /*break*/, 37];
                                case 'bad_timeout_mod': return [3 /*break*/, 38];
                                case 'bad_timeout_admin': return [3 /*break*/, 39];
                                case 'bad_timeout_global_mod': return [3 /*break*/, 39];
                                case 'bad_timeout_staff': return [3 /*break*/, 39];
                                case 'bad_vip_grantee_banned': return [3 /*break*/, 40];
                                case 'bad_vip_grantee_already_vip': return [3 /*break*/, 40];
                                case 'vip_success': return [3 /*break*/, 41];
                                case 'bad_unvip_grantee_not_vip': return [3 /*break*/, 42];
                                case 'unvip_success': return [3 /*break*/, 43];
                                case 'no_vips': return [3 /*break*/, 44];
                                case 'vips_success': return [3 /*break*/, 45];
                                case 'cmds_available': return [3 /*break*/, 46];
                                case 'followers_on': return [3 /*break*/, 47];
                                case 'followers_on_zero': return [3 /*break*/, 47];
                                case 'followers_off': return [3 /*break*/, 47];
                                case 'slow_on': return [3 /*break*/, 47];
                                case 'slow_off': return [3 /*break*/, 47];
                                case 'timeout_success': return [3 /*break*/, 48];
                                case 'host_off': return [3 /*break*/, 49];
                                case 'host_on': return [3 /*break*/, 49];
                                case 'host_target_went_offline': return [3 /*break*/, 49];
                                case 'unrecognized_cmd': return [3 /*break*/, 50];
                                case 'no_permission': return [3 /*break*/, 51];
                                case 'msg_ratelimit': return [3 /*break*/, 52];
                                case 'msg_banned': return [3 /*break*/, 53];
                                case undefined: return [3 /*break*/, 54];
                            }
                            return [3 /*break*/, 58];
                        case 1:
                            {
                                match = message.split(' ');
                                user = /^\w+$/.test(match[0]) ? match[0] : undefined;
                                if (user) {
                                    this.emit(this._onBanResult, channel, user, messageType);
                                }
                                return [3 /*break*/, 59];
                            }
                            _f.label = 2;
                        case 2:
                            {
                                this.emit(this._onBanResult, channel, this._credentials.nick, messageType);
                                return [3 /*break*/, 59];
                            }
                            _f.label = 3;
                        case 3:
                            {
                                this.emit(this._onBanResult, channel, toUserName(channel), messageType);
                                return [3 /*break*/, 59];
                            }
                            _f.label = 4;
                        case 4:
                            {
                                match = /^You cannot ban (?:\w+ )+?(\w+)\.$/.exec(message);
                                if (match) {
                                    this.emit(this._onBanResult, channel, match[1].toLowerCase(), messageType);
                                }
                                return [3 /*break*/, 59];
                            }
                            _f.label = 5;
                        case 5:
                            {
                                match = message.split(' ');
                                user = /^\w+$/.test(match[0]) ? match[0] : undefined;
                                if (user) {
                                    this.emit(this._onBanResult, channel, user);
                                }
                                return [3 /*break*/, 59];
                            }
                            _f.label = 6;
                        case 6:
                            {
                                match = message.split(' ');
                                user = /^\w+$/.test(match[0]) ? match[0] : undefined;
                                if (user) {
                                    this.emit(this._onUnbanResult, channel, user, messageType);
                                }
                                return [3 /*break*/, 59];
                            }
                            _f.label = 7;
                        case 7:
                            {
                                match = message.split(' ');
                                user = /^\w+$/.test(match[0]) ? match[0] : undefined;
                                if (user) {
                                    this.emit(this._onUnbanResult, channel, user);
                                }
                                return [3 /*break*/, 59];
                            }
                            _f.label = 8;
                        case 8:
                            {
                                this.emit(this._onColorResult, messageType);
                                return [3 /*break*/, 59];
                            }
                            _f.label = 9;
                        case 9:
                            {
                                this.emit(this._onColorResult);
                                return [3 /*break*/, 59];
                            }
                            _f.label = 10;
                        case 10:
                            {
                                this.emit(this._onCommercialResult, channel, messageType);
                                return [3 /*break*/, 59];
                            }
                            _f.label = 11;
                        case 11:
                            {
                                this.emit(this._onCommercialResult, channel);
                                return [3 /*break*/, 59];
                            }
                            _f.label = 12;
                        case 12:
                            {
                                this.emit(this._onDeleteMessageResult, channel, messageType);
                                return [3 /*break*/, 59];
                            }
                            _f.label = 13;
                        case 13:
                            {
                                this.emit(this._onDeleteMessageResult, channel);
                                return [3 /*break*/, 59];
                            }
                            _f.label = 14;
                        case 14:
                            {
                                this.emit(this._onEmoteOnlyResult, channel, messageType);
                                return [3 /*break*/, 59];
                            }
                            _f.label = 15;
                        case 15:
                            {
                                this.emit(this._onEmoteOnlyResult, channel);
                                this.emit(this.onEmoteOnly, channel, true);
                                return [3 /*break*/, 59];
                            }
                            _f.label = 16;
                        case 16:
                            {
                                this.emit(this._onEmoteOnlyOffResult, channel, messageType);
                                return [3 /*break*/, 59];
                            }
                            _f.label = 17;
                        case 17:
                            {
                                this.emit(this._onEmoteOnlyOffResult, channel);
                                this.emit(this.onEmoteOnly, channel, false);
                                return [3 /*break*/, 59];
                            }
                            _f.label = 18;
                        case 18:
                            {
                                this.emit(this._onHostResult, channel, messageType);
                                return [3 /*break*/, 59];
                            }
                            _f.label = 19;
                        case 19:
                            {
                                remainingHostsFromChar = +message[0];
                                remainingHosts = isNaN(remainingHostsFromChar) ? 0 : Number(remainingHostsFromChar);
                                this.emit(this._onHostResult, channel);
                                this.emit(this.onHostsRemaining, channel, remainingHosts);
                                return [3 /*break*/, 59];
                            }
                            _f.label = 20;
                        case 20:
                            {
                                this.emit(this._onUnhostResult, channel, messageType);
                                return [3 /*break*/, 59];
                            }
                            _f.label = 21;
                        case 21:
                            {
                                this.emit(this._onJoinResult, channel, undefined, messageType);
                                return [3 /*break*/, 59];
                            }
                            _f.label = 22;
                        case 22:
                            {
                                match = message.split(' ');
                                user = /^\w+$/.test(match[0]) ? match[0] : undefined;
                                if (user) {
                                    this.emit(this._onModResult, channel, user, messageType);
                                }
                                return [3 /*break*/, 59];
                            }
                            _f.label = 23;
                        case 23:
                            {
                                match = /^You have added (\w+) /.exec(message);
                                if (match) {
                                    this.emit(this._onModResult, channel, match[1]);
                                }
                                return [3 /*break*/, 59];
                            }
                            _f.label = 24;
                        case 24:
                            {
                                match = message.split(' ');
                                user = /^\w+$/.test(match[0]) ? match[0] : undefined;
                                if (user) {
                                    this.emit(this._onUnmodResult, channel, user, messageType);
                                }
                                return [3 /*break*/, 59];
                            }
                            _f.label = 25;
                        case 25:
                            {
                                match = /^You have removed (\w+) /.exec(message);
                                if (match) {
                                    this.emit(this._onUnmodResult, channel, match[1]);
                                }
                                return [3 /*break*/, 59];
                            }
                            _f.label = 26;
                        case 26:
                            {
                                this.emit(this._onModsResult, channel, []);
                                return [3 /*break*/, 59];
                            }
                            _f.label = 27;
                        case 27:
                            {
                                _d = __read(message.split(': '), 2), modList = _d[1];
                                mods = modList.split(', ');
                                this.emit(this._onModsResult, channel, mods);
                                return [3 /*break*/, 59];
                            }
                            _f.label = 28;
                        case 28:
                            {
                                this.emit(this._onR9kResult, channel, messageType);
                                return [3 /*break*/, 59];
                            }
                            _f.label = 29;
                        case 29:
                            {
                                this.emit(this._onR9kResult, channel);
                                this.emit(this.onR9k, channel, true);
                                return [3 /*break*/, 59];
                            }
                            _f.label = 30;
                        case 30:
                            {
                                this.emit(this._onR9kOffResult, channel, messageType);
                                return [3 /*break*/, 59];
                            }
                            _f.label = 31;
                        case 31:
                            {
                                this.emit(this._onR9kOffResult, channel);
                                this.emit(this.onR9k, channel, false);
                                return [3 /*break*/, 59];
                            }
                            _f.label = 32;
                        case 32:
                            {
                                this.emit(this._onSubsOnlyResult, channel, messageType);
                                return [3 /*break*/, 59];
                            }
                            _f.label = 33;
                        case 33:
                            {
                                this.emit(this._onSubsOnlyResult, channel);
                                this.emit(this.onSubsOnly, channel, true);
                                return [3 /*break*/, 59];
                            }
                            _f.label = 34;
                        case 34:
                            {
                                this.emit(this._onSubsOnlyOffResult, channel, messageType);
                                return [3 /*break*/, 59];
                            }
                            _f.label = 35;
                        case 35:
                            {
                                this.emit(this._onSubsOnlyOffResult, channel);
                                this.emit(this.onSubsOnly, channel, false);
                                return [3 /*break*/, 59];
                            }
                            _f.label = 36;
                        case 36:
                            {
                                this.emit(this._onTimeoutResult, channel, this._credentials.nick, undefined, messageType);
                                return [3 /*break*/, 59];
                            }
                            _f.label = 37;
                        case 37:
                            {
                                this.emit(this._onTimeoutResult, channel, toUserName(channel), undefined, messageType);
                                return [3 /*break*/, 59];
                            }
                            _f.label = 38;
                        case 38:
                            {
                                match = /^You cannot timeout moderator (\w+) unless/.exec(message);
                                if (match) {
                                    this.emit(this._onTimeoutResult, channel, toUserName(match[1]), undefined, messageType);
                                }
                                return [3 /*break*/, 59];
                            }
                            _f.label = 39;
                        case 39:
                            {
                                match = /^You cannot ban (?:\w+ )+?(\w+)\.$/.exec(message);
                                if (match) {
                                    this.emit(this._onTimeoutResult, channel, toUserName(match[1]), undefined, messageType);
                                }
                                return [3 /*break*/, 59];
                            }
                            _f.label = 40;
                        case 40:
                            {
                                match = message.split(' ');
                                user = /^\w+$/.test(match[0]) ? match[0] : undefined;
                                if (user) {
                                    this.emit(this._onVipResult, channel, user, messageType);
                                }
                                return [3 /*break*/, 59];
                            }
                            _f.label = 41;
                        case 41:
                            {
                                match = /^You have added (\w+) /.exec(message);
                                if (match) {
                                    this.emit(this._onVipResult, channel, match[1]);
                                }
                                return [3 /*break*/, 59];
                            }
                            _f.label = 42;
                        case 42:
                            {
                                match = message.split(' ');
                                user = /^\w+$/.test(match[0]) ? match[0] : undefined;
                                if (user) {
                                    this.emit(this._onUnvipResult, channel, user, messageType);
                                }
                                return [3 /*break*/, 59];
                            }
                            _f.label = 43;
                        case 43:
                            {
                                match = /^You have removed (\w+) /.exec(message);
                                if (match) {
                                    this.emit(this._onUnvipResult, channel, match[1]);
                                }
                                return [3 /*break*/, 59];
                            }
                            _f.label = 44;
                        case 44:
                            {
                                this.emit(this._onVipsResult, channel, []);
                                return [3 /*break*/, 59];
                            }
                            _f.label = 45;
                        case 45:
                            {
                                _e = __read(message.split(': '), 2), vipList = _e[1];
                                vips = vipList.split(', ');
                                this.emit(this._onVipsResult, channel, vips);
                                return [3 /*break*/, 59];
                            }
                            _f.label = 46;
                        case 46:
                            {
                                // do we really care?
                                return [3 /*break*/, 59];
                            }
                            _f.label = 47;
                        case 47:
                            {
                                return [3 /*break*/, 59];
                            }
                            _f.label = 48;
                        case 48:
                            {
                                return [3 /*break*/, 59];
                            }
                            _f.label = 49;
                        case 49:
                            {
                                return [3 /*break*/, 59];
                            }
                            _f.label = 50;
                        case 50:
                            {
                                return [3 /*break*/, 59];
                            }
                            _f.label = 51;
                        case 51:
                            {
                                this.emit(this.onNoPermission, channel, message);
                                return [3 /*break*/, 59];
                            }
                            _f.label = 52;
                        case 52:
                            {
                                this.emit(this.onMessageRatelimit, channel, message);
                                return [3 /*break*/, 59];
                            }
                            _f.label = 53;
                        case 53:
                            {
                                this.emit(this.onMessageFailed, channel, messageType);
                                return [3 /*break*/, 59];
                            }
                            _f.label = 54;
                        case 54:
                            if (!(message === 'Login authentication failed' ||
                                message === 'Improperly formatted AUTH' ||
                                message === 'Invalid NICK')) return [3 /*break*/, 57];
                            this._authVerified = false;
                            this._authFailureMessage = message;
                            this.emit(this.onAuthenticationFailure, message);
                            if (!this._authRetryTimer) {
                                this._authRetryTimer = ChatClient_1._getReauthenticateWaitTime();
                            }
                            secs = this._authRetryTimer.next().value;
                            if (secs !== 0) {
                                this._chatLogger.info("Retrying authentication in " + secs + " seconds");
                            }
                            return [4 /*yield*/, delay(secs * 1000)];
                        case 55:
                            _f.sent();
                            return [4 /*yield*/, this.reconnect()];
                        case 56:
                            _f.sent();
                            _f.label = 57;
                        case 57: return [3 /*break*/, 59];
                        case 58:
                            {
                                if (!messageType || messageType.substr(0, 6) !== 'usage_') {
                                    this._chatLogger.warn("Unrecognized notice ID: '" + messageType + "'");
                                }
                            }
                            _f.label = 59;
                        case 59: return [2 /*return*/];
                    }
                });
            });
        });
        return _this;
    }
    ChatClient_1 = ChatClient;
    /**
     * Creates a new Twitch chat client with the user info from the {@AuthProvider} instance.
     *
     * @deprecated Use the {@ChatClient} constructor instead.
     *
     * @expandParams
     *
     * @param authProvider The {@AuthProvider} instance to use for authentication.
     * @param options
     */
    ChatClient.forTwitchClient = function (authProvider, options) {
        if (options === void 0) { options = {}; }
        deprecate('[twitch-chat-client] ChatClient.forTwitchClient', 'Use the `ChatClient` constructor instead.');
        return new this(authProvider, options);
    };
    /**
     * Creates a new anonymous Twitch chat client.
     *
     * @expandParams
     *
     * @param options
     */
    ChatClient.anonymous = function (options) {
        if (options === void 0) { options = {}; }
        return new this(undefined, options);
    };
    ChatClient.prototype.connect = function () {
        return __awaiter(this, void 0, Promise, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!this._authProvider) {
                            this._updateCredentials({
                                nick: ChatClient_1._generateJustinfanNick(),
                                password: undefined
                            });
                        }
                        return [4 /*yield*/, _super.prototype.connect.call(this)];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Hosts a channel on another channel.
     *
     * @param target The host target, i.e. the channel that is being hosted.
     * @param channel The host source, i.e. the channel that is hosting. Defaults to the channel of the connected user.
     */
    ChatClient.prototype.host = function (channel, target) {
        return __awaiter(this, void 0, Promise, function () {
            var channelName;
            var _this = this;
            return __generator(this, function (_a) {
                channelName = toUserName(channel !== null && channel !== void 0 ? channel : this._credentials.nick);
                return [2 /*return*/, new Promise(function (resolve, reject) {
                        var e = _this._onHostResult(function (chan, error) {
                            if (toUserName(chan) === channelName) {
                                if (error) {
                                    reject(error);
                                }
                                else {
                                    resolve();
                                }
                                _this.removeListener(e);
                            }
                        });
                        void _this.say(channelName, "/host " + target);
                    })];
            });
        });
    };
    /**
     * Ends any host on a channel.
     *
     * This only works when in the channel that was hosted in order to provide feedback about success of the command.
     *
     * If you don't need this feedback, consider using {@ChatClient#unhostOutside} instead.
     *
     * @param channel The channel to end the host on. Defaults to the channel of the connected user.
     */
    ChatClient.prototype.unhost = function (channel) {
        if (channel === void 0) { channel = this._credentials.nick; }
        return __awaiter(this, void 0, Promise, function () {
            var _this = this;
            return __generator(this, function (_a) {
                channel = toUserName(channel);
                return [2 /*return*/, new Promise(function (resolve, reject) {
                        var e = _this._onUnhostResult(function (chan, error) {
                            if (toUserName(chan) === channel) {
                                if (error) {
                                    reject(error);
                                }
                                else {
                                    resolve();
                                }
                                _this.removeListener(e);
                            }
                        });
                        void _this.say(channel, '/unhost');
                    })];
            });
        });
    };
    /**
     * Ends any host on a channel.
     *
     * This works even when not in the channel that was hosted, but provides no feedback about success of the command.
     *
     * If you need feedback about success, use {@ChatClient#unhost} (but make sure you're in the channel you are hosting).
     *
     * @param channel The channel to end the host on. Defaults to the channel of the connected user.
     */
    ChatClient.prototype.unhostOutside = function (channel) {
        if (channel === void 0) { channel = this._credentials.nick; }
        return __awaiter(this, void 0, Promise, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.say(channel, '/unhost')];
            });
        });
    };
    /**
     * Bans a user from a channel.
     *
     * @param channel The channel to ban the user from. Defaults to the channel of the connected user.
     * @param user The user to ban from the channel.
     * @param reason The reason for the ban.
     */
    ChatClient.prototype.ban = function (channel, user, reason) {
        if (reason === void 0) { reason = ''; }
        return __awaiter(this, void 0, Promise, function () {
            var channelName;
            var _this = this;
            return __generator(this, function (_a) {
                channelName = toUserName(channel !== null && channel !== void 0 ? channel : this._credentials.nick);
                user = toUserName(user);
                return [2 /*return*/, new Promise(function (resolve, reject) {
                        var e = _this._onBanResult(function (_channel, _user, error) {
                            if (toUserName(_channel) === channelName && toUserName(_user) === user) {
                                if (error) {
                                    reject(error);
                                }
                                else {
                                    resolve();
                                }
                                _this.removeListener(e);
                            }
                        });
                        void _this.say(channelName, "/ban " + user + " " + reason);
                    })];
            });
        });
    };
    /**
     * Clears all messages in a channel.
     *
     * @param channel The channel to ban the user from. Defaults to the channel of the connected user.
     */
    ChatClient.prototype.clear = function (channel) {
        if (channel === void 0) { channel = this._credentials.nick; }
        return __awaiter(this, void 0, Promise, function () {
            var _this = this;
            return __generator(this, function (_a) {
                channel = toUserName(channel);
                return [2 /*return*/, new Promise(function (resolve) {
                        var e = _this.addInternalListener(_this.onChatClear, function (_channel) {
                            if (toUserName(_channel) === channel) {
                                resolve();
                                e.unbind();
                            }
                        });
                        void _this.say(channel, '/clear');
                    })];
            });
        });
    };
    /**
     * Changes your username color.
     *
     * @param color The hexadecimal code (prefixed with #) or color name to use for your username.
     *
     * Please note that only Twitch Turbo or Prime users can use hexadecimal codes for arbitrary colors.
     *
     * If you have neither of those, you can only choose from the following color names:
     *
     * Blue, BlueViolet, CadetBlue, Chocolate, Coral, DodgerBlue, Firebrick, GoldenRod, Green, HotPink, OrangeRed, Red, SeaGreen, SpringGreen, YellowGreen
     */
    ChatClient.prototype.changeColor = function (color) {
        return __awaiter(this, void 0, Promise, function () {
            var _this = this;
            return __generator(this, function (_a) {
                return [2 /*return*/, new Promise(function (resolve, reject) {
                        var e = _this._onColorResult(function (error) {
                            if (error) {
                                reject(error);
                            }
                            else {
                                resolve();
                            }
                            _this.removeListener(e);
                        });
                        void _this.say(GENERIC_CHANNEL, "/color " + color);
                    })];
            });
        });
    };
    /**
     * Runs a commercial break on a channel.
     *
     * @param channel The channel to run the commercial break on.
     * @param duration The duration of the commercial break.
     */
    ChatClient.prototype.runCommercial = function (channel, duration) {
        return __awaiter(this, void 0, Promise, function () {
            var _this = this;
            return __generator(this, function (_a) {
                channel = toUserName(channel);
                return [2 /*return*/, new Promise(function (resolve, reject) {
                        var e = _this._onCommercialResult(function (_channel, error) {
                            if (toUserName(_channel) === channel) {
                                if (error) {
                                    reject(error);
                                }
                                else {
                                    resolve();
                                }
                                _this.removeListener(e);
                            }
                        });
                        void _this.say(channel, "/commercial " + duration);
                    })];
            });
        });
    };
    /**
     * Deletes a message from a channel.
     *
     * @param channel The channel to delete the message from.
     * @param message The message (as message ID or message object) to delete.
     */
    ChatClient.prototype.deleteMessage = function (channel, message) {
        return __awaiter(this, void 0, Promise, function () {
            var messageId;
            var _this = this;
            return __generator(this, function (_a) {
                channel = toUserName(channel);
                messageId = extractMessageId(message);
                return [2 /*return*/, new Promise(function (resolve, reject) {
                        var e = _this._onDeleteMessageResult(function (_channel, error) {
                            if (toUserName(_channel) === channel) {
                                if (error) {
                                    reject(error);
                                }
                                else {
                                    resolve();
                                }
                                _this.removeListener(e);
                            }
                        });
                        void _this.say(channel, "/delete " + messageId);
                    })];
            });
        });
    };
    /**
     * Enables emote-only mode in a channel.
     *
     * @param channel The channel to enable emote-only mode in.
     */
    ChatClient.prototype.enableEmoteOnly = function (channel) {
        return __awaiter(this, void 0, Promise, function () {
            var _this = this;
            return __generator(this, function (_a) {
                channel = toUserName(channel);
                return [2 /*return*/, new Promise(function (resolve, reject) {
                        var e = _this._onEmoteOnlyResult(function (_channel, error) {
                            if (toUserName(_channel) === channel) {
                                if (error) {
                                    reject(error);
                                }
                                else {
                                    resolve();
                                }
                                _this.removeListener(e);
                            }
                        });
                        void _this.say(channel, '/emoteonly');
                    })];
            });
        });
    };
    /**
     * Disables emote-only mode in a channel.
     *
     * @param channel The channel to disable emote-only mode in.
     */
    ChatClient.prototype.disableEmoteOnly = function (channel) {
        return __awaiter(this, void 0, Promise, function () {
            var _this = this;
            return __generator(this, function (_a) {
                channel = toUserName(channel);
                return [2 /*return*/, new Promise(function (resolve, reject) {
                        var e = _this._onEmoteOnlyOffResult(function (_channel, error) {
                            if (toUserName(_channel) === channel) {
                                if (error) {
                                    reject(error);
                                }
                                else {
                                    resolve();
                                }
                                _this.removeListener(e);
                            }
                        });
                        void _this.say(channel, '/emoteonlyoff');
                    })];
            });
        });
    };
    /**
     * Enables followers-only mode in a channel.
     *
     * @param channel The channel to enable followers-only mode in.
     * @param minFollowTime The time (in minutes) a user needs to be following before being able to send messages.
     */
    ChatClient.prototype.enableFollowersOnly = function (channel, minFollowTime) {
        if (minFollowTime === void 0) { minFollowTime = 0; }
        return __awaiter(this, void 0, Promise, function () {
            var _this = this;
            return __generator(this, function (_a) {
                if (!Number.isInteger(minFollowTime) || minFollowTime < 0 || minFollowTime > 129600) {
                    throw new Error("Invalid minimum follow time: " + minFollowTime + ". It must be an integer between 0 and 129600.");
                }
                channel = toUserName(channel);
                return [2 /*return*/, new Promise(function (resolve, reject) {
                        var e = _this._onFollowersOnlyResult(function (_channel, _minFollowTime, error) {
                            if (toUserName(_channel) === channel && _minFollowTime === minFollowTime) {
                                if (error) {
                                    reject(error);
                                }
                                else {
                                    resolve();
                                }
                                _this.removeListener(e);
                            }
                        });
                        void _this.say(channel, "/followers " + (minFollowTime || ''));
                    })];
            });
        });
    };
    /**
     * Disables followers-only mode in a channel.
     *
     * @param channel The channel to disable followers-only mode in.
     */
    ChatClient.prototype.disableFollowersOnly = function (channel) {
        return __awaiter(this, void 0, Promise, function () {
            var _this = this;
            return __generator(this, function (_a) {
                channel = toUserName(channel);
                return [2 /*return*/, new Promise(function (resolve, reject) {
                        var e = _this._onFollowersOnlyOffResult(function (_channel, error) {
                            if (toUserName(_channel) === channel) {
                                if (error) {
                                    reject(error);
                                }
                                else {
                                    resolve();
                                }
                                _this.removeListener(e);
                            }
                        });
                        void _this.say(channel, '/followersoff');
                    })];
            });
        });
    };
    /**
     * Gives a user moderator rights in a channel.
     *
     * @param channel The channel to give the user moderator rights in.
     * @param user The user to give moderator rights.
     */
    ChatClient.prototype.mod = function (channel, user) {
        return __awaiter(this, void 0, Promise, function () {
            var _this = this;
            return __generator(this, function (_a) {
                channel = toUserName(channel);
                user = toUserName(user);
                return [2 /*return*/, new Promise(function (resolve, reject) {
                        var e = _this._onModResult(function (_channel, _user, error) {
                            if (toUserName(_channel) === channel && toUserName(_user) === user) {
                                if (error) {
                                    reject(error);
                                }
                                else {
                                    resolve();
                                }
                                _this.removeListener(e);
                            }
                        });
                        void _this.say(channel, "/mod " + user);
                    })];
            });
        });
    };
    /**
     * Takes moderator rights from a user in a channel.
     *
     * @param channel The channel to remove the user's moderator rights in.
     * @param user The user to take moderator rights from.
     */
    ChatClient.prototype.unmod = function (channel, user) {
        return __awaiter(this, void 0, Promise, function () {
            var _this = this;
            return __generator(this, function (_a) {
                channel = toUserName(channel);
                user = toUserName(user);
                return [2 /*return*/, new Promise(function (resolve, reject) {
                        var e = _this._onUnmodResult(function (_channel, _user, error) {
                            if (toUserName(_channel) === channel && toUserName(_user) === user) {
                                if (error) {
                                    reject(error);
                                }
                                else {
                                    resolve();
                                }
                                _this.removeListener(e);
                            }
                        });
                        void _this.say(channel, "/unmod " + user);
                    })];
            });
        });
    };
    /**
     * Retrieves a list of moderators in a channel.
     *
     * @param channel The channel to retrieve the moderators of.
     */
    ChatClient.prototype.getMods = function (channel) {
        return __awaiter(this, void 0, Promise, function () {
            var _this = this;
            return __generator(this, function (_a) {
                channel = toUserName(channel);
                return [2 /*return*/, new Promise(function (resolve) {
                        var e = _this._onModsResult(function (_channel, mods) {
                            if (toUserName(_channel) === channel) {
                                resolve(mods);
                                _this.removeListener(e);
                            }
                        });
                        void _this.say(channel, '/mods');
                    })];
            });
        });
    };
    /**
     * Enables r9k mode in a channel.
     *
     * @param channel The channel to enable r9k mode in.
     */
    ChatClient.prototype.enableR9k = function (channel) {
        return __awaiter(this, void 0, Promise, function () {
            var _this = this;
            return __generator(this, function (_a) {
                channel = toUserName(channel);
                return [2 /*return*/, new Promise(function (resolve, reject) {
                        var e = _this._onR9kResult(function (_channel, error) {
                            if (toUserName(_channel) === channel) {
                                if (error) {
                                    reject(error);
                                }
                                else {
                                    resolve();
                                }
                                _this.removeListener(e);
                            }
                        });
                        void _this.say(channel, '/r9kbeta');
                    })];
            });
        });
    };
    /**
     * Disables r9k mode in a channel.
     *
     * @param channel The channel to disable r9k mode in.
     */
    ChatClient.prototype.disableR9k = function (channel) {
        return __awaiter(this, void 0, Promise, function () {
            var _this = this;
            return __generator(this, function (_a) {
                channel = toUserName(channel);
                return [2 /*return*/, new Promise(function (resolve, reject) {
                        var e = _this._onR9kOffResult(function (_channel, error) {
                            if (toUserName(_channel) === channel) {
                                if (error) {
                                    reject(error);
                                }
                                else {
                                    resolve();
                                }
                                _this.removeListener(e);
                            }
                        });
                        void _this.say(channel, '/r9kbetaoff');
                    })];
            });
        });
    };
    /**
     * Enables slow mode in a channel.
     *
     * @param channel The channel to enable slow mode in.
     * @param delayBetweenMessages The time (in seconds) a user needs to wait between messages.
     */
    ChatClient.prototype.enableSlow = function (channel, delayBetweenMessages) {
        if (delayBetweenMessages === void 0) { delayBetweenMessages = 30; }
        return __awaiter(this, void 0, Promise, function () {
            var _this = this;
            return __generator(this, function (_a) {
                if (!Number.isInteger(delayBetweenMessages) || delayBetweenMessages < 1 || delayBetweenMessages > 1800) {
                    throw new Error("Invalid delay between messages: " + delayBetweenMessages + ". It must be an integer between 1 and 1800.");
                }
                channel = toUserName(channel);
                return [2 /*return*/, new Promise(function (resolve, reject) {
                        var e = _this._onSlowResult(function (_channel, _delay, error) {
                            if (toUserName(_channel) === channel) {
                                if (error) {
                                    reject(error);
                                }
                                else {
                                    resolve();
                                }
                                _this.removeListener(e);
                            }
                        });
                        void _this.say(channel, "/slow " + delayBetweenMessages);
                    })];
            });
        });
    };
    /**
     * Disables slow mode in a channel.
     *
     * @param channel The channel to disable slow mode in.
     */
    ChatClient.prototype.disableSlow = function (channel) {
        return __awaiter(this, void 0, Promise, function () {
            var _this = this;
            return __generator(this, function (_a) {
                channel = toUserName(channel);
                return [2 /*return*/, new Promise(function (resolve, reject) {
                        var e = _this._onSlowOffResult(function (_channel, error) {
                            if (toUserName(_channel) === channel) {
                                if (error) {
                                    reject(error);
                                }
                                else {
                                    resolve();
                                }
                                _this.removeListener(e);
                            }
                        });
                        void _this.say(channel, '/slowoff');
                    })];
            });
        });
    };
    /**
     * Enables subscribers-only mode in a channel.
     *
     * @param channel The channel to enable subscribers-only mode in.
     */
    ChatClient.prototype.enableSubsOnly = function (channel) {
        return __awaiter(this, void 0, Promise, function () {
            var _this = this;
            return __generator(this, function (_a) {
                channel = toUserName(channel);
                return [2 /*return*/, new Promise(function (resolve, reject) {
                        var e = _this._onSubsOnlyResult(function (_channel, error) {
                            if (toUserName(_channel) === channel) {
                                if (error) {
                                    reject(error);
                                }
                                else {
                                    resolve();
                                }
                                _this.removeListener(e);
                            }
                        });
                        void _this.say(channel, '/subscribers');
                    })];
            });
        });
    };
    /**
     * Disables subscribers-only mode in a channel.
     *
     * @param channel The channel to disable subscribers-only mode in.
     */
    ChatClient.prototype.disableSubsOnly = function (channel) {
        return __awaiter(this, void 0, Promise, function () {
            var _this = this;
            return __generator(this, function (_a) {
                channel = toUserName(channel);
                return [2 /*return*/, new Promise(function (resolve, reject) {
                        var e = _this._onSubsOnlyOffResult(function (_channel, error) {
                            if (toUserName(_channel) === channel) {
                                if (error) {
                                    reject(error);
                                }
                                else {
                                    resolve();
                                }
                                _this.removeListener(e);
                            }
                        });
                        void _this.say(channel, '/subscribersoff');
                    })];
            });
        });
    };
    /**
     * Times out a user in a channel and removes all their messages.
     *
     * @param channel The channel to time out the user in.
     * @param user The user to time out.
     * @param duration The time (in seconds) until the user can send messages again. Defaults to 1 minute.
     * @param reason
     */
    ChatClient.prototype.timeout = function (channel, user, duration, reason) {
        if (duration === void 0) { duration = 60; }
        if (reason === void 0) { reason = ''; }
        return __awaiter(this, void 0, Promise, function () {
            var _this = this;
            return __generator(this, function (_a) {
                if (!Number.isInteger(duration) || duration < 1 || duration > 1209600) {
                    throw new Error("Invalid timeout duration: " + duration + ". It must be an integer between 1 and 1209600.");
                }
                channel = toUserName(channel);
                return [2 /*return*/, new Promise(function (resolve, reject) {
                        var e = _this._onTimeoutResult(function (_channel, _user, _duration, error) {
                            if (toUserName(_channel) === channel && toUserName(_user) === user) {
                                if (error) {
                                    reject(error);
                                }
                                else {
                                    resolve();
                                }
                                _this.removeListener(e);
                            }
                        });
                        void _this.say(channel, "/timeout " + user + " " + duration + " " + reason);
                    })];
            });
        });
    };
    /**
     * Removes all messages of a user from a channel.
     *
     * @param channel The channel to purge the user's messages from.
     * @param user The user to purge.
     * @param reason The reason for the purge.
     */
    ChatClient.prototype.purge = function (channel, user, reason) {
        if (reason === void 0) { reason = ''; }
        return __awaiter(this, void 0, Promise, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.timeout(channel, user, 1, reason)];
            });
        });
    };
    /**
     * Gives a user VIP status in a channel.
     *
     * @param channel The channel to give the user VIP status in.
     * @param user The user to give VIP status.
     */
    ChatClient.prototype.addVip = function (channel, user) {
        return __awaiter(this, void 0, Promise, function () {
            var _this = this;
            return __generator(this, function (_a) {
                channel = toUserName(channel);
                user = toUserName(user);
                return [2 /*return*/, new Promise(function (resolve, reject) {
                        var e = _this._onVipResult(function (_channel, _user, error) {
                            if (toUserName(_channel) === channel && toUserName(_user) === user) {
                                if (error) {
                                    reject(error);
                                }
                                else {
                                    resolve();
                                }
                                _this.removeListener(e);
                            }
                        });
                        void _this.say(channel, "/vip " + user);
                    })];
            });
        });
    };
    /** @deprecated Use addVip instead. */
    // eslint-disable-next-line @typescript-eslint/naming-convention
    ChatClient.prototype.addVIP = function (channel, user) {
        return __awaiter(this, void 0, Promise, function () {
            return __generator(this, function (_a) {
                deprecate('[twitch-chat-client] ChatClient#addVIP', 'Use `addVip` instead.');
                return [2 /*return*/, this.addVip(channel, user)];
            });
        });
    };
    /**
     * Takes VIP status from a user in a channel.
     *
     * @param channel The channel to remove the user's VIP status in.
     * @param user The user to take VIP status from.
     */
    ChatClient.prototype.removeVip = function (channel, user) {
        return __awaiter(this, void 0, Promise, function () {
            var _this = this;
            return __generator(this, function (_a) {
                channel = toUserName(channel);
                user = toUserName(user);
                return [2 /*return*/, new Promise(function (resolve, reject) {
                        var e = _this._onUnvipResult(function (_channel, _user, error) {
                            if (toUserName(_channel) === channel && toUserName(_user) === user) {
                                if (error) {
                                    reject(error);
                                }
                                else {
                                    resolve();
                                }
                                _this.removeListener(e);
                            }
                        });
                        void _this.say(channel, "/unvip " + user);
                    })];
            });
        });
    };
    /** @deprecated Use removeVip instead. */
    // eslint-disable-next-line @typescript-eslint/naming-convention
    ChatClient.prototype.removeVIP = function (channel, user) {
        return __awaiter(this, void 0, Promise, function () {
            return __generator(this, function (_a) {
                deprecate('[twitch-chat-client] ChatClient#removeVIP', 'Use `removeVip` instead.');
                return [2 /*return*/, this.removeVip(channel, user)];
            });
        });
    };
    /**
     * Retrieves a list of VIPs in a channel.
     *
     * @param channel The channel to retrieve the VIPs of.
     */
    ChatClient.prototype.getVips = function (channel) {
        return __awaiter(this, void 0, Promise, function () {
            var _this = this;
            return __generator(this, function (_a) {
                channel = toUserName(channel);
                return [2 /*return*/, new Promise(function (resolve) {
                        var e = _this._onVipsResult(function (_channel, vips) {
                            if (toUserName(_channel) === channel) {
                                resolve(vips);
                                _this.removeListener(e);
                            }
                        });
                        void _this.say(channel, '/vips');
                    })];
            });
        });
    };
    /** @deprecated Use getVips instead. */
    // eslint-disable-next-line @typescript-eslint/naming-convention
    ChatClient.prototype.getVIPs = function (channel) {
        return __awaiter(this, void 0, Promise, function () {
            return __generator(this, function (_a) {
                deprecate('[twitch-chat-client] ChatClient#getVIPs', 'Use `getVips` instead.');
                return [2 /*return*/, this.getVips(channel)];
            });
        });
    };
    /**
     * Sends a message to a channel.
     *
     * @param channel The channel to send the message to.
     * @param message The message to send.
     * @param attributes The attributes to add to the message.
     */
    ChatClient.prototype.say = function (channel, message, attributes) {
        if (attributes === void 0) { attributes = {}; }
        return __awaiter(this, void 0, Promise, function () {
            var tags;
            return __generator(this, function (_a) {
                tags = {};
                if (attributes.replyTo) {
                    tags['reply-parent-msg-id'] = extractMessageId(attributes.replyTo);
                }
                return [2 /*return*/, this._messageRateLimiter.request({
                        type: 'say',
                        channel: toChannelName(channel),
                        message: message,
                        tags: tags
                    })];
            });
        });
    };
    /**
     * Sends an action message (/me) to a channel.
     *
     * @param channel The channel to send the message to.
     * @param message The message to send.
     */
    ChatClient.prototype.action = function (channel, message) {
        return __awaiter(this, void 0, Promise, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this._messageRateLimiter.request({
                        type: 'action',
                        channel: toChannelName(channel),
                        message: message
                    })];
            });
        });
    };
    /**
     * Sends a whisper message to another user.
     *
     * @param user The user to send the message to.
     * @param message The message to send.
     */
    ChatClient.prototype.whisper = function (user, message) {
        return __awaiter(this, void 0, Promise, function () {
            return __generator(this, function (_a) {
                if (this._needToShowWhisperWarning) {
                    this._needToShowWhisperWarning = false;
                    this._chatLogger.warn("You did not set a botLevel option.\nPlease note that your whispers might not arrive reliably if your bot is not a known or verified bot.");
                }
                return [2 /*return*/, this._whisperRateLimiter.request({
                        target: toUserName(user),
                        message: message
                    })];
            });
        });
    };
    /**
     * Joins a channel.
     *
     * @param channel The channel to join.
     */
    ChatClient.prototype.join = function (channel) {
        return __awaiter(this, void 0, Promise, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this._joinRateLimiter.request(toChannelName(channel))];
            });
        });
    };
    /**
     * Leaves a channel ("part" in IRC terms).
     *
     * @param channel The channel to leave.
     */
    ChatClient.prototype.part = function (channel) {
        _super.prototype.part.call(this, toChannelName(channel));
    };
    /**
     * Disconnects from the chat server.
     */
    ChatClient.prototype.quit = function () {
        return __awaiter(this, void 0, Promise, function () {
            var _this = this;
            return __generator(this, function (_a) {
                void this._connection.disconnect().then(function () {
                    _this._chatLogger.debug('Finished cleaning up old connection');
                });
                return [2 /*return*/];
            });
        });
    };
    /**
     * Waits for authentication (or "registration" in IRC terms) to finish.
     *
     * @deprecated Use the `onRegister` event instead. To join channels after connecting, use the `channels` option.
     */
    ChatClient.prototype.waitForRegistration = function () {
        return __awaiter(this, void 0, Promise, function () {
            var authListener;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        deprecate('[twitch-chat-client] ChatClient#waitForRegistration', 'Use the `onRegister` event instead. To join channels after connecting, use the `channels` option.');
                        if (this._registered) {
                            return [2 /*return*/];
                        }
                        if (this._authFailureMessage) {
                            throw new Error("Registration failed. Response from Twitch: " + this._authFailureMessage);
                        }
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, , 3, 4]);
                        return [4 /*yield*/, Promise.race([
                                new Promise(function (resolve, reject) {
                                    authListener = _this.addInternalListener(_this.onAuthenticationFailure, function (message) {
                                        reject(Error("Registration failed. Response from Twitch: " + message));
                                    });
                                }),
                                _super.prototype.waitForRegistration.call(this)
                            ])];
                    case 2:
                        _a.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        authListener === null || authListener === void 0 ? void 0 : authListener.unbind();
                        return [7 /*endfinally*/];
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    ChatClient.prototype.registerCoreMessageTypes = function () {
        _super.prototype.registerCoreMessageTypes.call(this);
        this.registerMessageType(TwitchPrivateMessage);
    };
    ChatClient.prototype.getPassword = function () {
        var _a, _b;
        return __awaiter(this, void 0, Promise, function () {
            var scopes, lastTokenError, _c, token, e_1, _d, token, e_2;
            return __generator(this, function (_e) {
                switch (_e.label) {
                    case 0:
                        if (!this._authProvider) {
                            return [2 /*return*/, undefined];
                        }
                        if (this._authToken && !this._authToken.isExpired && this._authVerified) {
                            this._chatLogger.debug('AccessToken assumed to be correct from last connection');
                            return [2 /*return*/, "oauth:" + this._authToken.accessToken];
                        }
                        scopes = this._getNecessaryScopes();
                        lastTokenError = undefined;
                        _e.label = 1;
                    case 1:
                        _e.trys.push([1, 5, , 6]);
                        _c = this;
                        return [4 /*yield*/, this._authProvider.getAccessToken(scopes)];
                    case 2:
                        _c._authToken = _e.sent();
                        if (!this._authToken) return [3 /*break*/, 4];
                        return [4 /*yield*/, getTokenInfo(this._authToken.accessToken)];
                    case 3:
                        token = _e.sent();
                        this._updateCredentials({
                            nick: token.userName
                        });
                        return [2 /*return*/, "oauth:" + this._authToken.accessToken];
                    case 4: return [3 /*break*/, 6];
                    case 5:
                        e_1 = _e.sent();
                        if (e_1 instanceof InvalidTokenError) {
                            lastTokenError = e_1;
                        }
                        else {
                            this._chatLogger.error("Retrieving an access token failed: " + e_1.message);
                        }
                        return [3 /*break*/, 6];
                    case 6:
                        this._chatLogger.warn('No valid token available; trying to refresh');
                        _e.label = 7;
                    case 7:
                        _e.trys.push([7, 11, , 12]);
                        _d = this;
                        return [4 /*yield*/, ((_b = (_a = this._authProvider).refresh) === null || _b === void 0 ? void 0 : _b.call(_a))];
                    case 8:
                        _d._authToken = _e.sent();
                        if (!this._authToken) return [3 /*break*/, 10];
                        return [4 /*yield*/, getTokenInfo(this._authToken.accessToken)];
                    case 9:
                        token = _e.sent();
                        this._updateCredentials({
                            nick: token.userName
                        });
                        return [2 /*return*/, "oauth:" + this._authToken.accessToken];
                    case 10: return [3 /*break*/, 12];
                    case 11:
                        e_2 = _e.sent();
                        if (e_2 instanceof InvalidTokenError) {
                            lastTokenError = e_2;
                        }
                        else {
                            this._chatLogger.error("Refreshing the access token failed: " + e_2.message);
                        }
                        return [3 /*break*/, 12];
                    case 12:
                        this._authVerified = false;
                        throw lastTokenError !== null && lastTokenError !== void 0 ? lastTokenError : new Error('Could not retrieve a valid token');
                }
            });
        });
    };
    ChatClient.prototype._doWhisper = function (user, message) {
        _super.prototype.say.call(this, GENERIC_CHANNEL, "/w " + user + " " + message);
    };
    ChatClient.prototype._getNecessaryScopes = function () {
        if (this._useLegacyScopes) {
            return ['chat_login'];
        }
        if (this._readOnly) {
            return ['chat:read'];
        }
        return ['chat:read', 'chat:edit'];
    };
    ChatClient._generateJustinfanNick = function () {
        var randomSuffix = Math.floor(Math.random() * 100000)
            .toString()
            .padStart(5, '0');
        return "justinfan" + randomSuffix;
    };
    // yes, this is just fibonacci with a limit
    ChatClient._getReauthenticateWaitTime = function () {
        var current, next;
        var _a;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    current = 0;
                    next = 1;
                    _b.label = 1;
                case 1:
                    if (!(current < 120)) return [3 /*break*/, 3];
                    return [4 /*yield*/, current];
                case 2:
                    _b.sent();
                    _a = __read([next, current + next], 2), current = _a[0], next = _a[1];
                    return [3 /*break*/, 1];
                case 3:
                    if (!true) return [3 /*break*/, 5];
                    return [4 /*yield*/, 120];
                case 4:
                    _b.sent();
                    return [3 /*break*/, 3];
                case 5: return [2 /*return*/];
            }
        });
    };
    var ChatClient_1;
    ChatClient.HOST_MESSAGE_REGEX = /(\w+) is now ((?:auto[- ])?)hosting you(?: for (?:up to )?(\d+))?/;
    __decorate([
        Enumerable(false)
    ], ChatClient.prototype, "_authProvider", void 0);
    ChatClient = ChatClient_1 = __decorate([
        rtfm('twitch-chat-client', 'ChatClient')
    ], ChatClient);
    return ChatClient;
}(IrcClient));
export { ChatClient };
